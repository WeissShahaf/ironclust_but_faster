# IronClust Bug Fixes - January 28, 2025

## Overview
Fixed three critical bugs in the manual curation workflow (`irc manual` command) that were preventing proper cluster merging and deletion operations.

---

## Issue 1: Cluster Number Inconsistency After Deletion

### Problem
When deleting clusters after merging, users received error popup:
```
Cluster number is inconsistent after deletion
```

**Root Cause:** The `S_clu_select_()` function only resized `mrWavCor` and `mrPos_clu` matrix fields during cluster deletion. Other `m*_clu` matrix fields (like `mrVmin_clu`, `mrColor_clu`, `mrDist_clu`, etc.) retained their old dimensions, causing validation to fail.

### Fix Location
**File:** `matlab/irc.m`
**Lines:** 18431-18489
**Function:** `S_clu_select_()`

### Changes Made
Added automatic handling for ALL `m*_clu` matrix fields:

```matlab
% Find all m*_clu fields
viMatch_m = cellfun(@(vi)~isempty(vi), cellfun(@(cs)regexp(cs, '^m\w*_clu$'), csNames, 'UniformOutput', false));
csNames_m = csNames(viMatch_m);

% Get old nClu for dimension checking
nClu_old = S_clu.nClu;
nClu_new = numel(viKeep_clu);

% Process each m*_clu field (except those already handled)
for iField = 1:numel(csNames_m)
    vcField = csNames_m{iField};

    % Skip fields already handled specially
    if strcmp(vcField, 'mrWavCor'), continue; end

    try
        mField = S_clu.(vcField);
        if isempty(mField), continue; end

        [nRows, nCols] = size(mField);

        % Determine how to resize based on dimensions
        if nRows == nClu_old && nCols == nClu_old
            % [nClu x nClu] matrix - select both dimensions
            S_clu.(vcField) = mField(viKeep_clu, viKeep_clu);
        elseif nRows == nClu_old
            % [nClu x X] matrix - select rows
            S_clu.(vcField) = mField(viKeep_clu, :);
        elseif nCols == nClu_old
            % [X x nClu] matrix - select columns
            S_clu.(vcField) = mField(:, viKeep_clu);
        else
            % Neither dimension matches nClu_old - this field may cause validation error
            fprintf(2, 'S_clu_select_: Warning - field %s has size [%d x %d], expected at least one dimension = %d\n', ...
                vcField, nRows, nCols, nClu_old);
        end
    catch ME
        % If there's an error processing this field, continue with others
        fprintf(2, 'S_clu_select_: Error resizing field %s: %s\n', vcField, ME.message);
    end
end
```

**Impact:** All matrix fields with `m*_clu` naming pattern are now automatically resized during cluster deletion operations.

---

## Issue 2: Second Cluster Selection Cleared After First Merge

### Problem
After queuing the first merge operation, navigating with arrow keys (without Shift) would clear the second cluster selection (`iCluPaste`), making it impossible to queue additional merges without re-selecting the second cluster each time.

**Root Cause:** The `update_cursor_()` function automatically cleared `iCluPaste` whenever updating `iCluCopy`, even when preserving the selection would be beneficial for sequential merge operations.

### Fix Location
**File:** `matlab/irc.m`
**Lines:** 5499-5506, 5468-5476
**Functions:** `update_cursor_()`, `button_CluWav_simulate_()`

### Changes Made

#### 1. In `update_cursor_()` (lines 5499-5506):
Removed automatic clearing of `iCluPaste`:

```matlab
if ~fPaste
    iCluCopy = iClu;
    if iCluCopy <1 || iCluCopy > S_clu.nClu, return; end
    % Don't automatically clear iCluPaste - preserve for sequential merge operations
    % Only hide the visual if iCluPaste is being explicitly cleared by caller
    % update_plot_(S0.hPaste, nan, nan); %hide paste
    % S0.iCluPaste = [];
    [S0.iCluCopy, S0.hCopy] = plot_tmrWav_clu_(S0, iCluCopy, S0.hCopy, [0 0 0]);
```

#### 2. In `button_CluWav_simulate_()` (lines 5468-5476):
Added explicit handling to clear `iCluPaste` only when intentionally requested:

```matlab
S0 = update_cursor_(S0, iCluCopy, 0);

% If iCluPaste is explicitly empty, clear it and hide the visual marker
if isempty(iCluPaste)
    if isfield(S0, 'hPaste') && ~isempty(S0.hPaste)
        update_plot_(S0.hPaste, nan, nan); % hide paste marker
    end
    S0.iCluPaste = [];
else
    S0 = update_cursor_(S0, iCluPaste, 1);
end
```

**Impact:** The second cluster selection (red marker) is now preserved when navigating with arrow keys, allowing users to queue multiple merge operations without having to re-select the second cluster each time.

**When `iCluPaste` IS cleared:**
- Clicking on the diagonal (same cluster) in correlation matrix
- Pressing 'u' to execute pending operations
- Explicitly passing empty value to `button_CluWav_simulate_()`

---

## Issue 3: Empty Quality Fields After Merge Causing Deletion Failures

### Problem
After successfully merging clusters, subsequent delete operations would fail with the same "Cluster number is inconsistent" error. Debug output showed that `vrSnr_clu` and `vnSite_clu` fields had size 0 instead of nClu.

**Root Cause:** The `S_clu_quality_()` function runs after merges to recalculate cluster quality metrics. When it fails (specifically with "no Sevt in memory"), the catch block was setting quality fields to empty arrays `[]`:

```matlab
catch
    [vrVrms_site, vrSnr_clu, vnSite_clu] = deal([]);  % Overwrites existing values!
    disp('no Sevt in memory.');
end
```

Then `struct_add_()` would overwrite the existing correctly-sized fields with these empty arrays.

### Fix Location
**File:** `matlab/irc.m`
**Lines:** 17563-17581
**Function:** `S_clu_quality_()`

### Changes Made
Modified the catch block to preserve existing field values instead of overwriting with empty:

```matlab
catch
    % Preserve existing values if they exist, otherwise use empty
    if isfield(S_clu, 'vrVrms_site')
        vrVrms_site = S_clu.vrVrms_site;
    else
        vrVrms_site = [];
    end
    if isfield(S_clu, 'vrSnr_clu')
        vrSnr_clu = S_clu.vrSnr_clu;
    else
        vrSnr_clu = [];
    end
    if isfield(S_clu, 'vnSite_clu')
        vnSite_clu = S_clu.vnSite_clu;
    else
        vnSite_clu = [];
    end
    disp('no Sevt in memory.');
end
```

**Impact:** Quality metric fields (`vrSnr_clu`, `vnSite_clu`, `vrVrms_site`) are now preserved when quality recalculation fails, preventing validation errors during subsequent delete operations.

---

## Additional Improvements

### Enhanced Error Reporting in `struct_select_()` (lines 18417-18423)
Improved error messages to show field name, size, and actual error when resizing fails:

```matlab
catch ME
    % Better error reporting - show field name, size, and actual error
    fprintf(2, 'struct_select_: Error resizing field "%s" (size=%s, viKeep=%d elements): %s\n', ...
        vcName_, mat2str(size(S.(vcName_))), numel(viKeep), ME.message);
    % Don't silently continue - re-throw to make error visible
    rethrow(ME);
end
```

---

## Testing Workflow

To verify all fixes are working:

1. **Restart MATLAB** or run `clear all` to reload modified code
2. Load data and run `irc manual`
3. **Test merge operations:**
   - Select cluster 1 (arrow keys)
   - Select cluster 2 (Shift+arrow keys) - observe red marker
   - Press 'm' to queue merge
   - Use arrow keys to select cluster 3 - red marker should remain visible
   - Press Shift+arrow to change to cluster 4
   - Press 'm' to queue another merge - should work without error
   - Press 'u' to execute all pending merges
4. **Test delete operations:**
   - Select a cluster
   - Press 'd' or 'Delete' to queue deletion
   - Press 'u' to execute - should work without "inconsistent cluster number" error

---

## Files Modified

- `matlab/irc.m`
  - Lines 5468-5476: `button_CluWav_simulate_()` - preserve iCluPaste
  - Lines 5499-5506: `update_cursor_()` - don't auto-clear iCluPaste
  - Lines 17526-17541: `S_clu_quality_()` - preserve and expand vrVpp_clu etc.
  - Lines 17548-17574: `S_clu_quality_()` - preserve and expand vrSnr_clu, vnSite_clu
  - Lines 18417-18423: `struct_select_()` - better error reporting
  - Lines 18431-18489: `S_clu_select_()` - resize all m*_clu fields

---

## Backward Compatibility

These changes are fully backward compatible. They:
- Only affect manual curation workflow
- Fix bugs without changing intended behavior
- Add defensive programming to handle edge cases
- Preserve all existing functionality

---

## Issue 4: Array Size Mismatch After Merge-Then-Split/Delete Operations

### Problem
After merging clusters and then attempting to split or delete a cluster, users received an indexing error:
```
struct_select_: Error resizing field "vrSnr_clu" (size=[104 1], viKeep=105 elements):
Index exceeds the number of array elements. Index must not exceed 104.
```

The error trace showed:
```
Error in irc>struct_select_ (line 18413)
Error in irc>S_clu_select_ (line 18453)
Error in irc>clu_reorder_ (line 9382)
Error in irc>split_clu_ (line 9673)
Error in irc>auto_split_ (line 9000)
```

**Root Cause:**
1. After a merge, `S_clu.nClu` is updated to reflect the new cluster count (e.g., 104)
2. When a split occurs, `split_clu_()` sets `S_clu.nClu = 105` (the new max cluster ID)
3. `S_clu_update_()` calls `S_clu_quality_()` to recalculate quality metrics
4. `S_clu_quality_()` hits an error (e.g., "no Sevt in memory") and falls into the catch block
5. The catch block (Issue 3 fix) preserves the old `vrSnr_clu` with 104 elements
6. However, it doesn't expand the array to match the new `S_clu.nClu = 105`
7. Later, `clu_reorder_()` tries to remap all 105 clusters using `S_clu_select_()`
8. `struct_select_()` attempts to index `vrSnr_clu[105]` but the array only has 104 elements â†’ **Error!**

### Fix Location
**File:** `matlab/irc.m`
**Lines:** 17526-17574
**Function:** `S_clu_quality_()`

### Changes Made

#### 1. Enhanced First Catch Block (lines 17526-17541):
Now preserves old values and expands them to match `S_clu.nClu`:

```matlab
catch
    disp('S_clu_quality_: error');
    % Preserve old values or initialize with zeros to match nClu
    vrVpp_clu = get_(S_clu, 'vrVpp_clu');
    vrVmin_clu = get_(S_clu, 'vrVmin_clu');
    vrVpp_uv_clu = get_(S_clu, 'vrVpp_uv_clu');
    vrVmin_uv_clu = get_(S_clu, 'vrVmin_uv_clu');
    if isempty(vrVpp_clu), vrVpp_clu = zeros(S_clu.nClu, 1); end
    if numel(vrVpp_clu) < S_clu.nClu, vrVpp_clu(end+1:S_clu.nClu) = 0; end
    if isempty(vrVmin_clu), vrVmin_clu = zeros(S_clu.nClu, 1); end
    if numel(vrVmin_clu) < S_clu.nClu, vrVmin_clu(end+1:S_clu.nClu) = 0; end
    if isempty(vrVpp_uv_clu), vrVpp_uv_clu = zeros(S_clu.nClu, 1); end
    if numel(vrVpp_uv_clu) < S_clu.nClu, vrVpp_uv_clu(end+1:S_clu.nClu) = 0; end
    if isempty(vrVmin_uv_clu), vrVmin_uv_clu = zeros(S_clu.nClu, 1); end
    if numel(vrVmin_uv_clu) < S_clu.nClu, vrVmin_uv_clu(end+1:S_clu.nClu) = 0; end
end
```

#### 2. Enhanced Second Catch Block (lines 17548-17574):
Added array expansion logic for preserved values:

```matlab
catch
    % Preserve existing values if they exist, otherwise use empty
    % IMPORTANT: Expand arrays to match S_clu.nClu if necessary
    if isfield(S_clu, 'vrVrms_site')
        vrVrms_site = S_clu.vrVrms_site;
    else
        vrVrms_site = [];
    end
    if isfield(S_clu, 'vrSnr_clu')
        vrSnr_clu = S_clu.vrSnr_clu;
        % Expand to match nClu if too small
        if numel(vrSnr_clu) < S_clu.nClu
            vrSnr_clu(end+1:S_clu.nClu) = 0;
        end
    else
        vrSnr_clu = [];
    end
    if isfield(S_clu, 'vnSite_clu')
        vnSite_clu = S_clu.vnSite_clu;
        % Expand to match nClu if too small
        if numel(vnSite_clu) < S_clu.nClu
            vnSite_clu(end+1:S_clu.nClu) = 0;
        end
    else
        vnSite_clu = [];
    end
    disp('no Sevt in memory.');
end
```

**Impact:**
- Quality metric arrays are now automatically expanded when preserved during error handling
- Prevents indexing errors when cluster operations increase `S_clu.nClu`
- Ensures all `v*_clu` fields remain consistent with `S_clu.nClu`
- New clusters get zero-initialized quality metrics until properly calculated

**Key Principle:**
When preserving array values during error recovery, always ensure they match the current `S_clu.nClu` dimension. Zero-fill any missing elements.

---

## Credits

Fixes developed and tested: January 28, 2025
Issues reported by: User during manual curation session
Root cause analysis: Systematic debugging with detailed error logging
